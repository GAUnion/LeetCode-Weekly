# 题目75

给定一个包含红色、白色和蓝色，一共*n*个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数0、1和2分别表示红色、白色和蓝色。

## 示例：

```
输入：[2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

## 进阶：

* 一个直观的解决方案是使用计数排序的两趟扫描算法。
  首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。

* 你能想出一个仅使用常数空间的一趟扫描算法吗？

## 解析：

最直观的解法是先遍历一遍数组，数出0，1，2的个数，再重写一遍数组。但如果要求只遍历一遍数组来求解，那么便可以设置两个指针分别从数组的头和尾向中心移动。

定义*j*指针指向开头位置，*k*指针指向末尾位置。

定义*i*指针从头开始遍历原数组，如果遇到0，则交换该值与*j*指针所指向的值，并将j指针后移一位。若遇到2，则交换该值与*k*指针所指向的值，并将*k*指针前移一位。

**值得注意的是，当*i*指针与*k*指针交换完毕后，需要将*i*减1，从而在下一次循环中继续判断该位置的值是否需要与指针*j*或指针*k*指向的值进行交换，因为从*k*处交换回来的值有可能是0或2。而从*j*指针交换回来的值只可能是1，因此不需要再次判断。**

当*i*指针超过*k*指针的时候，排序完毕。

## 代码：

```c++
class Solution {
public:
​    void sortColors(vector<int>& nums) {
​        for (int i = 0, j = 0, k = nums.size() - 1; i <= k; ++i) {
​            if (nums[i] == 0) {
​                swap(nums[i], nums[j++]);
​            }
​            else if (nums[i] == 2) {
​                swap(nums[i--], nums[k--]);
​            }
​        }
​    }
};
```

# 题目88

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *num1* 成为一个有序数组。

## 说明:

* 初始化 *nums1* 和 *nums2* 的元素数量分别为 *m* 和 *n* 。

* 你可以假设 *nums1* 有足够的空间（空间大小大于或等于 *m + n*）来保存 *nums2* 中的元素。

## 示例:

```markdown
输入：
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3

输出：[1,2,2,3,5,6]
```

## 解析：

从*nums1*和*nums2*数组的末尾开始一个一个比较，把较大的数，按顺序从后往前加入混合之后的数组末尾。需要三个指针*i*，*j*，*k*分别指向混合数组，*nums1*的末尾和*nums2*的末尾。进行while循环，如果*j*和*k*都大于等于0，则将*nums1[j]*和*nums2[k]*进行比较，将较大者加入混合数组的末尾，并同时将*i*和*j*或*k*自减1。当*j*和*k*中有一个小于0时，循环结束。如果此时*k*大于等于0，则将*nums2*中的剩下元素拷贝入*nums1*，如果*j*大于等于0，则不需要采取操作。

## 代码：

```c++
class Solution {
public:
​    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
​        int i = m + n - 1, j = m - 1, k = n - 1;
​        while (j >= 0 && k >= 0) {
​            if (nums1[j] >= nums2[k]) nums1[i--] = nums1[j--];
​            else nums1[i--] = nums2[k--];
​        }
​        while (k >= 0) nums1[i--] = nums2[k--];
​    }
};
```

# 题目153

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

## 示例1:

```
输入：[3,4,5,1,2]
输出：1
```

## 示例2:

```
输入：[4,5,6,7,0,1,2]
输出：0
```

## 解析：

直接遍历整个数组为最简单的解法，但时间复杂度为O(n)，我们应尽量把查找算法的时间复杂度降至O(logn)。O(logn)的解法首先便想到二分查找。这里我们使用中间值与最右端的值进行比较。在寻找旋转点的过程中，因为该数组为升序排列，因此如果mid<right，则数组未发生旋转或者旋转点发生在数组左半段。如果mid>right，则数组的旋转点发生在右半段。

## 代码：

```c++
class Solution {
public:
​    int findMin(vector<int>& nums) {
​        int left = 0, right = nums.size() - 1;
​        while (left < right) {
​            int mid = (left + right) / 2;
​            if (nums[mid] > nums[right]) left = mid + 1;
​            else right = mid;
​        }
​        return nums[left];
​    }
};
```

# 题目162

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

## 示例1:

```
输入：nums = [1,2,3,1]
输出：2
```

## 示例2:

```
输入： nums = [1,2,1,3,5,6,4]
输出：1或5
```

## 说明：

你的解法应该是O(logN)时间复杂度的。

## 解析：

首先介绍*O(N)*时间复杂度的解法，由于给定条件 `nums[-1] = nums[n] = -∞`，因此*nums[0]*是大于*nums[-1]*的，我们可以从*nums[1]*开始遍历，如果该数字小于*nums[0]*，则说明*nums[0]*是一个局部峰值。否则向后遍历，由于现在是个递增的趋势，所以我们只要找到一个数字小于他前面的数字，则说明前面的数字是个局部峰值，返回其位置即可。如果循环结束了，说明是个递增的数组，则返回最后一个位置即可。

由该线性时间复杂度的解法可以推广到*O(logN)*的解法，看到*O(logN)*首先想到二分查找。通过上一种解法我们可以得到结论：在一个`nums[-1] = nums[n] = -∞`的数组中必定存在局部峰值。我们可以推广该结论：**在两端点外的值小于两端点的数组内必存在局部峰值**。因此我们首先计算*mid*的值，如果`mid < mid + 1`，则*mid+1*到*right*必存在局部峰值，反之如果`mid > mid + 1`，则*left*到*mid*必存在局部峰值。

## 代码：

```c++
class Solution {
public:
​    int findPeakElement(vector<int>& nums) {
​        int left = 0, right = nums.size() - 1;
​        while (left < right) {
​            int mid = (left + right) / 2;
​            if (nums[mid] < nums[mid + 1]) left = mid + 1;
​            else right = mid;
​        }
​        return right;
​    }
};
```

